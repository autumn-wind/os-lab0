1.针对我们的框架代码, 描述系统启动的过程, 即系统是如何从开机跳转到游戏中的第一条语句的? 讲义的前半部分对这个过程有大致的描述, 你需要深入其中的相关细节来回答这个问题.
答：系统启动后，设置CS = 0xf000, IP = 0xfff0（硬件完成），这个地址是内存映射机制下BIOS的第一条指令对应的物理地址。于是CPU将开始执行BIOS的第一条指令，并且是运行在实模式下。BIOS在完成一系列操作后（硬件检查，加载BIOS中断向量和相关服务程序），将第一个检测到的可启动设备的第一个扇区的内容加载到内存的0x7c00处，然后设置CS = 0x0000, IP = 0x7c00, 于是CPU将开始执行start.s的第一条指令。
	程序首先关闭外部中断，再设置段寄存器，然后打开A20地址线，使程序的可寻址空间达到2^32＝4GB。接着设置GDT表和加载gtdr寄存器，为进入保护模式做准备。然后置CR0寄存器的PE位，通过一条长跳转指令使CPU从之前的实模式进入保护模式。进入保护模式后，程序重新设置段寄存器以及esp。之后从汇编代码跳转到C代码执行。
	C代码先将游戏ELF文件的文件头读入内存，然后根据ELF文件头中的记录从磁盘相应位置读取游戏程序的代码段，数据段到内存的0x100000位置（内存地址在编译游戏文件时确定）。装载完毕后，程序将跳转到游戏代码的第一条指令。注意此时外部中断仍然处于屏蔽状态。

2.时钟中断到来/某个键被按下之后, 直到从中断返回的这段时间, 计算机硬件和软件究竟做了什么? 这个问题涉及到中断的处理过程, 你需要选择一种中断源(时钟/键盘), 结合框架代码, 深入计算机层面来回答这个问题, 尤其需要关注硬件的行为和其中涉及的汇编代码.
答：以时钟中断举例。
	当定时器（8253）输出一个信号到irq0线上，pic将这个信号转换为中断向量号32发送给CPU。CPU本来按序即将执行下一条指令i1，但是发现在执行上一条指令时发生了中断，于是先根据idtr和中断向量寻找到相应的中断服务程序入口，然后将当前的eflags，cs，eip（即对应着i1指令）压栈，接着跳转到中断服务程序执行。时钟中断的服务程序首先将1000压入栈中，然后执行pushal指令将相关寄存器全部入栈，之后执行push esp指令将当前esp值入栈，作为此后irq_handle函数的参数。紧接着跳转到irq_handle函数。
	irq_handle函数通过此前压入的常数值1000判断发生了时钟中断，于是执行do_timer函数，函数执行完后返回irq_handle函数，接着irq_handle函数再返回，执行汇编指令将此前压入的（esp，各种寄存器，常数1000）全部清栈，最后再iret退出中断服务程序。
	iret将保存在栈中的值装载eflags，cs，eip寄存器，于是cpu将从之前被中断的i1指令处继续顺序执行。

3.事实上, 并不是每一个地址都能用作栈顶指针, 你知道可以设置栈顶指针的内存地址需要满足什么条件吗?

4.我们知道使用cache可以提高访问内存的速度, 但是对于用作内存映射I/O的内存区域, 使用cache可能会造成不可预料的结果. 因此一般会将这部分内存设置为不可缓存, 这样, 每一次对它们的访问都不会经过cache, 而是老老实实地访问相应的"内存区域". 你知道这其中的缘由吗?

5.思考一下, IA-32怎么样对内存映射I/O进行保护? 尝试查阅i386手册对比你的想法.
答：（我的猜测）将映射的物理页设置为内核属性（超级用户）或者用户属性。若设置为内核属性，则当CPL＝3的代码访问这个地址时，CPU将抛出一个异常。

6.我们知道进行函数调用的时候也需要保存调用者的状态: 返回地址, 而进行中断处理之前却要保存更多的信息. 尝试对比它们, 并思考两者保存信息不同是什么原因造成的.
答：中断前后代码的特权级很可能不同，cpu的运行状态也可能不一致。

7.如果你通过命令./game直接运行游戏, 将会产生段错误, 你知道这是为什么吗?
答：因为游戏代码里涉及到很多I／O操作，使用./game执行游戏时代码运行在特权级3，使用I／O指令或通过内存映射的方式直接访问外设时，由于IOPL＝0或者对应页属性为超级用户，导致CPU抛出一个异常，即产生了段错误。

8.代码中有一处关中断操作, 但执行少量语句之后很快就重新打开中断了. 你能想明白这里的关中断有什么用意吗? (这个问题会有一些难度)

实验过程中遇到的问题与总结：
a.开始并不知道该如何实现中断机制，后来先去翻越了《深入理解Linux内核》这本书，才发现以前一直以为懂的很多概念其实都是模糊的，现在总结如下：
	我们通常所说的CPU的中断分为同步中断和异步中断，同步中断是CPU在执行某些指令时遇到一些情况，由CPU自己发出的中断信号。而异步中断则是外部设备或定时器发出的中断信号。同步中断在intel手册中被称为异常，异步中断被称为中断。我们通常所说的“int80中断”，也即系统调用的入口，其实属于同步中断，是一种异常。然后不论是同步中断（下文统称为异常）还是异步中断（下文统称为中断）都对应一个中断向量，CPU拿到这个中断向量后就去IDT表里查找对应的服务程序入口。
	异常和中断不同的是，异常对应的中断向量由CPU自己给出，或者由程序中的命令给出（如int 0x80），而中断（大部分，NMI好像不是这种情况）则是由外部设备通过irq线发送信号给pic，pic再将这个信号转换为中断向量发送给CPU。一般pic会将irq号＋32转换为中断向量，原因是intel将前32个中断向量已经保留己用。并且irq中断都是可屏蔽中断，可以通过设置eflas中的IF位选择是否屏蔽外部irq中断。
	cpu得到中断向量号后，会去idt里查找对应的服务程序入口，这里在段级保护上要做一个（或两个）检查。首先对于所有的中断都必须检查当前的CPL必须大于等于中断服务程序的DPL（IDT表里段选择符对应GDT表的段描述符里的DPL），这样是保证中断服务程序的特权级必须不低于引起中断的程序。对于编程中断，则要进一步检查当前的CPL必须小于等于中断门（或陷阱门）的DPL，这样做的目的是保证用户程序不能访问特殊的（高特权级，内核才能实用的）陷阱门或中断门。
	不管当前程序和中断服务程序是否是同一特权级，硬件都要完成对eflags，cs，eip的压栈。如果前后特权级不一致，则需要先切换为中断服务程序的栈，然后压栈保存之前的ss，esp，eflags，cs，eip。如果硬件产生了一个硬件出错码，则也将它保存在栈中。当中断处理完后，执行最后一条iret指令时，硬件会将之前保存在栈中的数据全部出栈。

b.开始编写printk函数时，不太清楚void ＊＊的使用，后来重新翻了一下大一C语言的书，整理了一下要点和思路，总结如下：（32位操作系统）
	void＊可以用来存储任意的地址值，但不能对其进行解引用。另外尝试了一下发现sizeof(void)等于1。
	当声明一个指针type *p后，对p＋1，实际上p存储的地址值是加上sizeof(type)。所以这里用void ＊＊args是保证每次args＋＋后，args存储的地址值加上sizeof(void *), 也即4。
	函数调用，参数压栈时，每个参数占用4个字节，如果参数长度不足4个字节，比如char类型，则省下的3字节填0，不使用，以保证对齐。
	



